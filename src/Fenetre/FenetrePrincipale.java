/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Fenetre;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.awt.image.RasterFormatException;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author Pierre
 */
public class FenetrePrincipale extends javax.swing.JFrame {

    protected BufferedImage bimgSrc = null;
    private BufferedImage bimgOri = null; 
    protected BufferedImage bimgDst = null;
    int x1, y1, x2, y2; // coord x et y du rectangle pour ROI 
    boolean roi = false;
    int values[], minValue, maxValue;

    /**
     * Creates new form FenetrePrincipale
     */
    public FenetrePrincipale() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        UpdateSourceImage = new javax.swing.JButton();
        ZoomButton = new javax.swing.JButton();
        ChoixZoom = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        ImageDst = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        ImageSrc = new javax.swing.JLabel();
        Expan_Extra_Button = new javax.swing.JButton();
        ThresholdButton = new javax.swing.JButton();
        ChoixThreshold = new javax.swing.JTextField();
        ChoixExpanExtracX = new javax.swing.JTextField();
        ChoixExpanExtracY = new javax.swing.JTextField();
        histoImg1 = new javax.swing.JLabel();
        histoImg2 = new javax.swing.JLabel();
        EgalisationButton = new javax.swing.JButton();
        erosionButton = new javax.swing.JButton();
        erosionTxt = new javax.swing.JTextField();
        dilatationButton = new javax.swing.JButton();
        dilatationTxt = new javax.swing.JTextField();
        ouvertureButton = new javax.swing.JButton();
        ouvertureTxt = new javax.swing.JTextField();
        fermetureButton = new javax.swing.JButton();
        fermetureTxt = new javax.swing.JTextField();
        jMenuBar1 = new javax.swing.JMenuBar();
        MenuFile = new javax.swing.JMenu();
        MenuLoadImage = new javax.swing.JMenuItem();
        MenuOperations = new javax.swing.JMenu();
        ROIMenu = new javax.swing.JMenuItem();
        PaletteMenu = new javax.swing.JMenuItem();
        MultiThresholdMenu = new javax.swing.JMenuItem();
        MenuMasques = new javax.swing.JMenu();
        medianMenu = new javax.swing.JMenuItem();
        moyenMenu = new javax.swing.JMenuItem();
        gaussienMenu = new javax.swing.JMenuItem();
        laplacienMenu = new javax.swing.JMenuItem();
        MenuFiltres = new javax.swing.JMenu();
        kirshMenu = new javax.swing.JMenuItem();
        sobelMenu = new javax.swing.JMenuItem();
        prewittMenu = new javax.swing.JMenuItem();
        robertsMenu = new javax.swing.JMenuItem();

        jButton1.setText("jButton1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Image Processing");
        setResizable(false);

        UpdateSourceImage.setText("<<");
        UpdateSourceImage.setEnabled(false);
        UpdateSourceImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UpdateSourceImageActionPerformed(evt);
            }
        });

        ZoomButton.setText("Zoom:");
        ZoomButton.setEnabled(false);
        ZoomButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ZoomButtonActionPerformed(evt);
            }
        });

        ChoixZoom.setEnabled(false);
        ChoixZoom.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                ChoixZoomKeyPressed(evt);
            }
        });

        ImageDst.setLabelFor(ImageDst);
        ImageDst.setFocusable(false);
        jScrollPane1.setViewportView(ImageDst);

        ImageSrc.setLabelFor(ImageSrc);
        ImageSrc.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                ImageSrcMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                ImageSrcMouseReleased(evt);
            }
        });
        jScrollPane2.setViewportView(ImageSrc);

        Expan_Extra_Button.setText("Expansion / Extraction:");
        Expan_Extra_Button.setEnabled(false);
        Expan_Extra_Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Expan_Extra_ButtonActionPerformed(evt);
            }
        });

        ThresholdButton.setText("Threshold:");
        ThresholdButton.setEnabled(false);
        ThresholdButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ThresholdButtonActionPerformed(evt);
            }
        });

        ChoixThreshold.setEnabled(false);
        ChoixThreshold.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                ChoixThresholdKeyPressed(evt);
            }
        });

        ChoixExpanExtracX.setEnabled(false);
        ChoixExpanExtracX.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                ChoixExpanExtracXKeyPressed(evt);
            }
        });

        ChoixExpanExtracY.setEnabled(false);
        ChoixExpanExtracY.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                ChoixExpanExtracYKeyPressed(evt);
            }
        });

        histoImg1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        histoImg2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        EgalisationButton.setText("Egalisation");
        EgalisationButton.setEnabled(false);
        EgalisationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EgalisationButtonActionPerformed(evt);
            }
        });

        erosionButton.setText("Erosion");
        erosionButton.setEnabled(false);
        erosionButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                erosionButtonActionPerformed(evt);
            }
        });

        erosionTxt.setEnabled(false);
        erosionTxt.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                erosionTxtKeyPressed(evt);
            }
        });

        dilatationButton.setText("Dilatation");
        dilatationButton.setEnabled(false);
        dilatationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                dilatationButtonActionPerformed(evt);
            }
        });

        dilatationTxt.setEnabled(false);
        dilatationTxt.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                dilatationTxtKeyPressed(evt);
            }
        });

        ouvertureButton.setText("Ouverture");
        ouvertureButton.setEnabled(false);
        ouvertureButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ouvertureButtonActionPerformed(evt);
            }
        });

        ouvertureTxt.setEnabled(false);
        ouvertureTxt.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                ouvertureTxtKeyPressed(evt);
            }
        });

        fermetureButton.setText("Fermeture");
        fermetureButton.setEnabled(false);
        fermetureButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fermetureButtonActionPerformed(evt);
            }
        });

        fermetureTxt.setEnabled(false);
        fermetureTxt.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                fermetureTxtKeyPressed(evt);
            }
        });

        MenuFile.setText("File");

        MenuLoadImage.setText("Load image");
        MenuLoadImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MenuLoadImageActionPerformed(evt);
            }
        });
        MenuFile.add(MenuLoadImage);

        jMenuBar1.add(MenuFile);

        MenuOperations.setText("Operations");

        ROIMenu.setText("R.O.I.");
        ROIMenu.setEnabled(false);
        ROIMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ROIMenuActionPerformed(evt);
            }
        });
        MenuOperations.add(ROIMenu);

        PaletteMenu.setText("Palette");
        PaletteMenu.setEnabled(false);
        PaletteMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PaletteMenuActionPerformed(evt);
            }
        });
        MenuOperations.add(PaletteMenu);

        MultiThresholdMenu.setText("Multi Threshold");
        MultiThresholdMenu.setEnabled(false);
        MultiThresholdMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MultiThresholdMenuActionPerformed(evt);
            }
        });
        MenuOperations.add(MultiThresholdMenu);

        jMenuBar1.add(MenuOperations);

        MenuMasques.setText("Masques");

        medianMenu.setText("Median");
        medianMenu.setEnabled(false);
        medianMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                medianMenuActionPerformed(evt);
            }
        });
        MenuMasques.add(medianMenu);

        moyenMenu.setText("Moyen");
        moyenMenu.setEnabled(false);
        moyenMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                moyenMenuActionPerformed(evt);
            }
        });
        MenuMasques.add(moyenMenu);

        gaussienMenu.setText("Gaussien");
        gaussienMenu.setEnabled(false);
        gaussienMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gaussienMenuActionPerformed(evt);
            }
        });
        MenuMasques.add(gaussienMenu);

        laplacienMenu.setText("Laplacien");
        laplacienMenu.setEnabled(false);
        laplacienMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                laplacienMenuActionPerformed(evt);
            }
        });
        MenuMasques.add(laplacienMenu);

        jMenuBar1.add(MenuMasques);

        MenuFiltres.setText("Filtres");

        kirshMenu.setText("Kirsh");
        kirshMenu.setEnabled(false);
        kirshMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                kirshMenuActionPerformed(evt);
            }
        });
        MenuFiltres.add(kirshMenu);

        sobelMenu.setText("Sobel");
        sobelMenu.setEnabled(false);
        sobelMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sobelMenuActionPerformed(evt);
            }
        });
        MenuFiltres.add(sobelMenu);

        prewittMenu.setText("Prewitt");
        prewittMenu.setEnabled(false);
        prewittMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                prewittMenuActionPerformed(evt);
            }
        });
        MenuFiltres.add(prewittMenu);

        robertsMenu.setText("Roberts");
        robertsMenu.setEnabled(false);
        robertsMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                robertsMenuActionPerformed(evt);
            }
        });
        MenuFiltres.add(robertsMenu);

        jMenuBar1.add(MenuFiltres);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(50, 50, 50)
                        .addComponent(ZoomButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ChoixZoom, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(Expan_Extra_Button)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ChoixExpanExtracX, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ChoixExpanExtracY, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(ThresholdButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ChoixThreshold, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(25, 25, 25)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(histoImg1, javax.swing.GroupLayout.PREFERRED_SIZE, 260, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, Short.MAX_VALUE)
                                .addComponent(EgalisationButton)
                                .addGap(18, 18, 18)
                                .addComponent(histoImg2, javax.swing.GroupLayout.PREFERRED_SIZE, 260, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 285, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(UpdateSourceImage)
                                .addGap(18, 18, 18)
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 285, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(39, 39, 39)
                        .addComponent(erosionButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(erosionTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(dilatationButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(dilatationTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(ouvertureButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ouvertureTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(fermetureButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fermetureTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(25, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(126, 126, 126)
                        .addComponent(UpdateSourceImage))
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 285, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 285, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(histoImg2, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(histoImg1, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(64, 64, 64)
                        .addComponent(EgalisationButton)))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ZoomButton)
                    .addComponent(ThresholdButton)
                    .addComponent(ChoixZoom, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Expan_Extra_Button)
                    .addComponent(ChoixThreshold, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ChoixExpanExtracX, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ChoixExpanExtracY, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(erosionButton)
                    .addComponent(erosionTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(dilatationButton)
                    .addComponent(dilatationTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ouvertureButton)
                    .addComponent(ouvertureTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(fermetureButton)
                    .addComponent(fermetureTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /*------------------------ Méthodes utiles ------------------------*/
    private void UpdateSourceImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UpdateSourceImageActionPerformed
        // passer image destination en image source
        bimgSrc = copyImage(bimgDst);
        Icon im = new ImageIcon(bimgSrc);
        ImageSrc.setIcon(im);

        updateHistogram(histoImg1, ImageSrc);
    }//GEN-LAST:event_UpdateSourceImageActionPerformed

    public static BufferedImage copyImage(BufferedImage src) {
        BufferedImage b = new BufferedImage(src.getWidth(), src.getHeight(), src.getType());
        Graphics g = b.getGraphics();
        g.drawImage(src, 0, 0, null);
        g.dispose();
        return b;
    }

    protected BufferedImage getBufferedImage(ImageIcon icon) {
        BufferedImage bi = new BufferedImage(
                icon.getIconWidth(),
                icon.getIconHeight(),
                BufferedImage.TYPE_INT_RGB);

        Graphics g = bi.createGraphics();
        // paint the Icon to the BufferedImage.
        icon.paintIcon(null, g, 0, 0);
        g.dispose();
        return bi;
    }
    
    public void enableAll(boolean b) {
        // on rend les boutons disponibles car on a une image 
        ZoomButton.setEnabled(b);
        ChoixZoom.setEnabled(b);
        ROIMenu.setEnabled(b);
        PaletteMenu.setEnabled(b);
        ChoixThreshold.setEnabled(b);
        ThresholdButton.setEnabled(b);
        ChoixExpanExtracX.setEnabled(b);
        ChoixExpanExtracY.setEnabled(b);
        Expan_Extra_Button.setEnabled(b);
        MultiThresholdMenu.setEnabled(b);
        UpdateSourceImage.setEnabled(b);
        EgalisationButton.setEnabled(b);
        medianMenu.setEnabled(b);
        moyenMenu.setEnabled(b);
        gaussienMenu.setEnabled(b);
        laplacienMenu.setEnabled(b);
        kirshMenu.setEnabled(b);
        sobelMenu.setEnabled(b);
        prewittMenu.setEnabled(b);
        robertsMenu.setEnabled(b);
        erosionButton.setEnabled(b);
        erosionTxt.setEnabled(b);
        dilatationButton.setEnabled(b);
        dilatationTxt.setEnabled(b);
        ouvertureButton.setEnabled(b);
        ouvertureTxt.setEnabled(b);
        fermetureButton.setEnabled(b);
        fermetureTxt.setEnabled(b);
    }

    /*------------------------ Dans fenêtres ------------------------*/
    private void MenuLoadImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MenuLoadImageActionPerformed
        // Ouvre un sélecteur de fichier et affiche l'image choisie par l'uti 
        int retour;

        JFileChooser choix = new JFileChooser(); // selecteur de fichier 
        FileFilter imagesFilter = new FileNameExtensionFilter("Images", "bmp", "jpg", "jpeg", "png"); // filtre des fichier que l'on peut ouvrir 
        choix.addChoosableFileFilter(imagesFilter); // ajout du filtre 
        choix.setAcceptAllFileFilterUsed(false); // on ne peut pas choisir autre chose 
        choix.setFileFilter(imagesFilter); // application du filtre 

        retour = choix.showOpenDialog(getParent()); // ouvre la fenetre de choix de fichier
        if (retour == JFileChooser.APPROVE_OPTION) { // un fichier a été choisi (bouton OK) 
            try {
                bimgSrc = ImageIO.read(new File(choix.getSelectedFile().getAbsolutePath()));
                bimgOri = ImageIO.read(new File(choix.getSelectedFile().getAbsolutePath())); 
            } catch (IOException e) {} 
            Image img = bimgSrc.getScaledInstance((int) (bimgSrc.getWidth()), (int) (bimgSrc.getHeight()), Image.SCALE_SMOOTH); // dimensionnement de l'image dans le label 

            Icon ico = new ImageIcon(img);
            ImageSrc.setIcon(ico);

            enableAll(true);
            updateHistogram(histoImg1, ImageSrc);
        }
    }//GEN-LAST:event_MenuLoadImageActionPerformed

    private void ZoomButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ZoomButtonActionPerformed
        // (Dé)Zoomer l'image source et la mettre en image dst 
        // Attention, il faut le faire avec le nombre demandé par l'uti dans ChoixZoom 
        try {
            float zoom;
            zoom = Float.parseFloat(ChoixZoom.getText());

            if (!ChoixZoom.getText().equals("") && zoom > 0) {
                Image im = bimgSrc.getScaledInstance((int) (bimgSrc.getWidth() * zoom), (int) (bimgSrc.getHeight() * zoom), Image.SCALE_DEFAULT);
                Icon ico = new ImageIcon(im);
                ImageDst.setIcon(ico);
                updateHistogram(histoImg2, ImageDst);
            }
        } catch (NumberFormatException e) {
        }
    }//GEN-LAST:event_ZoomButtonActionPerformed

    private void ChoixZoomKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_ChoixZoomKeyPressed
        // lance le zoom en appuyant sur enter 
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            ZoomButtonActionPerformed(null);
    }//GEN-LAST:event_ChoixZoomKeyPressed

    private void ImageSrcMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_ImageSrcMousePressed
        // Récupère point de l'image quand on appuie 
        x1 = evt.getX();
        y1 = evt.getY();
    }//GEN-LAST:event_ImageSrcMousePressed

    private void ImageSrcMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_ImageSrcMouseReleased
        // Récupère point de l'image où on relache 
        x2 = evt.getX();
        y2 = evt.getY();

        // on calcule le rectangle selectionné et on affiche l'image correspondante en destination 
        if (roi) {
            try {
                Rectangle rect = new Rectangle(x1, y1, x2 - x1, y2 - y1);
                roi = false;
                bimgDst = bimgSrc.getSubimage((int) (rect.x), (int) (rect.y), (int) (rect.width), (int) (rect.height));

                Icon ico = new ImageIcon(bimgDst);
                ImageDst.setIcon(ico);
                updateHistogram(histoImg2, ImageDst);
            } catch (RasterFormatException e) {
            }
        }
    }//GEN-LAST:event_ImageSrcMouseReleased

    private void PaletteMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PaletteMenuActionPerformed
        // Ouvre une fenetre avec une palette de couleur qu'on appliquera a l'image 
        FenetrePalette fp = new FenetrePalette(this);
        fp.setVisible(true);
        enableAll(false); 
    }//GEN-LAST:event_PaletteMenuActionPerformed

    private void ROIMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ROIMenuActionPerformed
        // Passe dans le mode R.O.I. donc on peut choisir une partie de l'image a afficher 
        roi = roi != true;
    }//GEN-LAST:event_ROIMenuActionPerformed

    private void Expan_Extra_ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Expan_Extra_ButtonActionPerformed
        // Realise l'expansion de l'image si >1 et si <1 l'extraction 
        try {
            ImageIcon icon = (ImageIcon) ImageSrc.getIcon();
            BufferedImage img = getBufferedImage(icon);
            float expExtrX, expExtrY;
            expExtrX = Float.parseFloat(ChoixExpanExtracX.getText());
            expExtrY = Float.parseFloat(ChoixExpanExtracY.getText());

            if (!ChoixExpanExtracX.getText().equals("") && !ChoixExpanExtracX.getText().equals("") && expExtrX > 0 && expExtrY > 0) {
                BufferedImage img2 = scale(img, expExtrX, expExtrY);
                bimgDst = img2;
                ImageDst.setIcon(new ImageIcon(img2));
                updateHistogram(histoImg2, ImageDst);
            }
        } catch (NumberFormatException e) {
        }

    }//GEN-LAST:event_Expan_Extra_ButtonActionPerformed

    private void ThresholdButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ThresholdButtonActionPerformed
        // Threshold de l'image 
        try {
            ImageIcon icon = (ImageIcon) ImageSrc.getIcon();
            BufferedImage img = getBufferedImage(icon);
            int thres = Integer.parseInt(ChoixThreshold.getText());
            int rgba;

            if (!ChoixThreshold.getText().equals("") && thres > 0 && thres < 255) {
                for (int i = 0; i < img.getWidth(); i++) {
                    for (int j = 0; j < img.getHeight(); j++) {
                        rgba = img.getRGB(i, j);
                        if ((rgba & 0xFF) < thres) {
                            img.setRGB(i, j, (rgba & 0xFF000000));
                        } else {
                            img.setRGB(i, j, ((rgba & 0xFF000000) + 0x00FFFFFF));
                        }
                    }
                }
                bimgDst = img;
                ImageDst.setIcon(new ImageIcon(img));
                updateHistogram(histoImg2, ImageDst);
            }
        } catch (NumberFormatException e) {} 
    }//GEN-LAST:event_ThresholdButtonActionPerformed

    private void ChoixThresholdKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_ChoixThresholdKeyPressed
        // lance le threshold en appuyant sur enter 
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            ThresholdButtonActionPerformed(null);
    }//GEN-LAST:event_ChoixThresholdKeyPressed

    private void ChoixExpanExtracXKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_ChoixExpanExtracXKeyPressed
        // lance l'expansion/extraction en appuyant sur enter 
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            Expan_Extra_ButtonActionPerformed(null);
    }//GEN-LAST:event_ChoixExpanExtracXKeyPressed

    private void ChoixExpanExtracYKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_ChoixExpanExtracYKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            Expan_Extra_ButtonActionPerformed(null);
    }//GEN-LAST:event_ChoixExpanExtracYKeyPressed

    private void MultiThresholdMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MultiThresholdMenuActionPerformed
        // ouvre fenetre pour le multi threshold 
        FenetreMultiThreshold fmt = new FenetreMultiThreshold(this);
        fmt.setVisible(true);
        enableAll(false); 
    }//GEN-LAST:event_MultiThresholdMenuActionPerformed

    private void EgalisationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EgalisationButtonActionPerformed
        // egalisation de l'histogramme 
        Egalisation();
    }//GEN-LAST:event_EgalisationButtonActionPerformed

    private void medianMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_medianMenuActionPerformed
        // TODO add your handling code here:
        medianFilter(); 
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_medianMenuActionPerformed

    private void moyenMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_moyenMenuActionPerformed
        // TODO add your handling code here:
        meanFilter(); 
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_moyenMenuActionPerformed

    private void gaussienMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_gaussienMenuActionPerformed
        // TODO add your handling code here:
        GaussianSigma gs = new GaussianSigma(this); 
        gs.setVisible(true);
    }//GEN-LAST:event_gaussienMenuActionPerformed

    private void laplacienMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_laplacienMenuActionPerformed
        // TODO add your handling code here:
        laplacienFilter(); 
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_laplacienMenuActionPerformed

    private void kirshMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_kirshMenuActionPerformed
        // TODO add your handling code here:
        ComboFiltres cf = new ComboFiltres(this, 1);
        cf.setVisible(true); 
    }//GEN-LAST:event_kirshMenuActionPerformed

    private void sobelMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sobelMenuActionPerformed
        // TODO add your handling code here:
        sobelFilter(); 
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_sobelMenuActionPerformed

    private void prewittMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_prewittMenuActionPerformed
        // TODO add your handling code here:
        prewittFilter(); 
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_prewittMenuActionPerformed

    private void robertsMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_robertsMenuActionPerformed
        // TODO add your handling code here:
        ComboFiltres cf = new ComboFiltres(this, 2); 
        cf.setVisible(true); 
    }//GEN-LAST:event_robertsMenuActionPerformed

    private void erosionButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_erosionButtonActionPerformed
        // TODO add your handling code here:
        if(erosionTxt.getText().equals("")) { 
            Erosion(128, null);
        }
        else { 
            int val = Integer.parseInt(erosionTxt.getText());
            Erosion(val, null);
        }
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_erosionButtonActionPerformed

    private void dilatationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_dilatationButtonActionPerformed
        // TODO add your handling code here:
        if(dilatationTxt.getText().equals("")) {
            Dilatation(128, null);
        }
        else { 
            int val = Integer.parseInt(dilatationTxt.getText());
            Dilatation(val, null);
        }
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_dilatationButtonActionPerformed

    private void ouvertureButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ouvertureButtonActionPerformed
        // TODO add your handling code here:
        BufferedImage img = null;
        if(ouvertureTxt.getText().equals("")) {
            img = copyImage(Erosion(128, null));
            bimgSrc = copyImage(bimgDst); 
            Dilatation(128, copyImage(img));
            bimgSrc = copyImage(bimgOri); 
        }
        else {
            int val = Integer.parseInt(ouvertureTxt.getText());
            img = copyImage(Erosion(val, null));
            bimgSrc = copyImage(bimgDst); 
            Dilatation(val, copyImage(img)); 
            bimgSrc = copyImage(bimgOri); 
        }
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_ouvertureButtonActionPerformed

    private void fermetureButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fermetureButtonActionPerformed
        // TODO add your handling code here:
        BufferedImage img = copyImage(bimgSrc);
        if(fermetureTxt.getText().equals("")) {
            img = copyImage(Dilatation(128, null));
            bimgSrc = copyImage(bimgDst); 
            Erosion(128, img); 
            bimgSrc = copyImage(bimgOri); 
        }
        else {
            int val = Integer.parseInt(fermetureTxt.getText());
            img = copyImage(Dilatation(val, null));
            bimgSrc = copyImage(bimgDst); 
            Erosion(val, img);
            bimgSrc = copyImage(bimgOri); 
        }
        updateHistogram(histoImg2, ImageDst);
    }//GEN-LAST:event_fermetureButtonActionPerformed

    private void erosionTxtKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_erosionTxtKeyPressed
        // TODO add your handling code here:
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            erosionButtonActionPerformed(null);
    }//GEN-LAST:event_erosionTxtKeyPressed

    private void dilatationTxtKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_dilatationTxtKeyPressed
        // TODO add your handling code here:
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            dilatationButtonActionPerformed(null);
    }//GEN-LAST:event_dilatationTxtKeyPressed

    private void ouvertureTxtKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_ouvertureTxtKeyPressed
        // TODO add your handling code here:
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            ouvertureButtonActionPerformed(null);
    }//GEN-LAST:event_ouvertureTxtKeyPressed

    private void fermetureTxtKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_fermetureTxtKeyPressed
        // TODO add your handling code here:
        if (evt.getKeyCode() == KeyEvent.VK_ENTER)
            fermetureButtonActionPerformed(null);
    }//GEN-LAST:event_fermetureTxtKeyPressed
    
    /*------------------------ Filtres ------------------------*/
    /*------------------------ médian, moyen, gaussien, laplacien ------------------------*/ 
    public void medianFilter() {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc); 
        
        int[] P=new int[9];
        int[] R=new int[9];
        int[] B=new int[9];
        int[] G=new int[9];
        
        int sumR = 0, sumB = 0, sumG = 0, avgR, avgB, avgG;
        int pixel;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
               sumB = 0;
               sumR = 0;
               sumG = 0;
                
               try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
               }
               catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
               }

               for(int k=0;k<9;k++) {                   
                   R[k] = (P[k]>>16)&0xff;
                   B[k] = (P[k]>>8)&0xff; 
                   G[k] = P[k]&0xff; 
               }
               
               Arrays.sort(R);
               Arrays.sort(B);
               Arrays.sort(G);
               
               pixel = (255<<24) | (R[4]<<16) | (B[4]<<8) | G[4];
               tmp.setRGB(i, j, pixel); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    public void meanFilter() {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int[] P=new int[9];
        int[] R=new int[9];
        int[] B=new int[9];
        int[] G=new int[9];
        
        int sumR = 0, sumB = 0, sumG = 0, avgR, avgB, avgG;
        int pixel;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
               sumB = 0;
               sumR = 0;
               sumG = 0;
                
               try {
                     P[0]=img.getRGB(i-1,j-1);
                     P[1]=img.getRGB(i-1,j);
                     P[2]=img.getRGB(i-1,j+1);
                     P[3]=img.getRGB(i,j+1);
                     P[4]=img.getRGB(i+1,j+1);
                     P[5]=img.getRGB(i+1,j);
                     P[6]=img.getRGB(i+1,j-1);
                     P[7]=img.getRGB(i,j-1);
                     P[8]=img.getRGB(i,j);
               }
               catch(IndexOutOfBoundsException e) {
                     P[0]=0;
                     P[1]=0;
                     P[2]=0;
                     P[3]=0;
                     P[4]=0;
                     P[5]=0;
                     P[6]=0;
                     P[7]=0;
                     P[8]=img.getRGB(i,j);   
               }

               for(int k=0;k<9;k++) {                   
                   R[k] = (P[k]>>16)&0xff;
                   B[k] = (P[k]>>8)&0xff; 
                   G[k] = P[k]&0xff; 
               }
               
               for(int k=0;k<9;k++) {                   
                   sumR += R[k];
                   sumB += B[k];
                   sumG += G[k];
               }
               
               avgR = sumR/R.length;
               avgB = sumB/B.length;
               avgG = sumG/G.length;
               
               pixel = (255<<24) | (avgR<<16) | (avgB<<8) | avgG; 
               tmp.setRGB(i, j, pixel); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    public void laplacienFilter() {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int[] P = new int[9]; // Pixel
        int[] Avg = new int[9];
        
        int r, g, b;
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
                }

                for(int k=0; k<9; k++) {                   
                    r = (P[k]>>16)&0xff;
                    b = (P[k]>>8)&0xff; 
                    g = P[k]&0xff;

                    Avg[k] = (r+b+g)/3;
                }

                int res = Avg[1] + Avg[3] -4*Avg[4] + Avg[5] + Avg[7];
                res = Math.abs(res);
                
                res = (res<<24) | (res<<16) | (res<<8) | res;
                tmp.setRGB(i, j, res); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    public double gauss(int x, int y, double sigma) {
        double coeff = 1/(2*Math.PI*sigma*sigma);
        double exposant = -((x*x + y*y) / (2*sigma*sigma));
        double res = coeff*Math.pow(Math.E, exposant);
        
        return res;
    }
    
    public void gaussFilter(double sigma) {
        int taille = (int) (2* Math.ceil((3*sigma)) + 1);
        
        double[][] masque = new double[taille][taille];
        int x, y, i = 0, j = 0;
        int pixel;
        
        x = -(int)(Math.floor(taille/2));
        y = -(int)(Math.floor(taille/2));
        
        // Calcul du masque
        for(i = 0; i < taille; i++) {
            x = -(int)(Math.floor(taille/2));
            for(j = 0; j < taille; j++) {
                masque[i][j] = gauss(x, y, sigma);
                x++;
            }
            y++;
        }
        
        // Calcul de la matrice normalisée entière
        double tmpmin = masque[0][0];
        double sum = 0;
        for(i = 0; i < taille; i++) {
            for(j = 0; j < taille; j++) {
                masque[i][j] = masque[i][j]/tmpmin;
                sum += masque[i][j];
            }
        }
        
        int tot = (int)sum; 
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int[][] P = new int[taille][taille]; // Pixel
        int[][] r = new int[taille][taille];
        int[][] g = new int[taille][taille];
        int[][] b = new int[taille][taille];
          
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        int k, l;
        double resR = 0;
        double resB = 0;
        double resG = 0;
        
        x = -(int)(Math.floor(taille/2));
        y = -(int)(Math.floor(taille/2));
        
        // boucle de parcours de l'image
        for (i = 0; i < width; i++) { 
            for (j = 0; j < height; j++) { 
                try {
                    // Recuperation des taille*taille pixels autours du pixel actuel
                    for(k = 0; k < taille; k++) {
                        for(l = 0; l < taille; l++) {
                            P[k][l] = img.getRGB(i-x+k , j-y+l);
                        }
                    }
                }
                catch(IndexOutOfBoundsException e) { // Si en dehors de l'image, on pourrait faire mieux que 0 
                    for(k = 0; k < taille; k++) {
                        for(l = 0; l < taille; l++) {
                            P[k][l] = 0;
                        }
                    }
                }

                // Grayscale pour chaque pixel
                for(k = 0; k < taille; k++) {
                    for(l = 0; l < taille; l++) {
                        r[k][l] = (P[k][l]>>16)&0xff;
                        b[k][l] = (P[k][l]>>8)&0xff; 
                        g[k][l] = P[k][l]&0xff;
                    }
                }

                // Application du masque
                resR = 0;
                resB = 0;
                resG = 0;
                for(k = 0; k < taille; k++) {
                    for(l = 0; l < taille; l++) {
                        resR += (masque[k][l]* (double)(r[k][l]));
                        resB += (masque[k][l]* (double)(b[k][l]));
                        resG += (masque[k][l]* (double)(g[k][l]));
                    }
                }

                resR /= (double)tot; // Ne pas oublier de diviser par le total pour récupérer des valeurs cohérentes
                resB /= (double)tot;
                resG /= (double)tot;

                resR = Math.abs(resR);
                resB = Math.abs(resB);
                resG = Math.abs(resG);

                pixel = ( (255<<24) | ((int)resR<<16) | ((int)resB<<8) | (int)resG); 
                tmp.setRGB(i, j, pixel); // On met le pixel dans la nouvelle image
            }
        } 
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    /*------------------------ Kirsh, Sobel, Prewitt, Roberts ------------------------*/ 
    public void kirshFilter(String centre) { 
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int[] P = new int[9]; // Pixel
        int[] Avg = new int[9];
        
        int r, g, b;
        int pixel;
        int max = 0;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
                }

                for(int k=0; k<9; k++) {                   
                    r = (P[k]>>16)&0xff;
                    b = (P[k]>>8)&0xff; 
                    g = P[k]&0xff;

                    Avg[k] = (r+b+g)/3;
                }

                int[] res = new int[8];
                // Reste à calculer res pour les HUIT matrices et prendre le résultat le plus grand
               
                res[0] = 3*Avg[0] + 3*Avg[1] + 3*Avg[2] + 3*Avg[3] + 3*Avg[5] - 5*Avg[6] - 5*Avg[7] - 5*Avg[8];
                res[0] = Math.abs(res[0]);

                res[1] = 3*Avg[0] + 3*Avg[1] + 3*Avg[2] - 5*Avg[3] + 3*Avg[5] - 5*Avg[6] - 5*Avg[7] + 3*Avg[8];
                res[1] = Math.abs(res[1]);
                
                res[2] = -5*Avg[0] + 3*Avg[1] + 3*Avg[2] - 5*Avg[3] + 3*Avg[5] - 5*Avg[6] + 3*Avg[7] + 3*Avg[8];
                res[2] = Math.abs(res[2]);
                
                res[3] = -5*Avg[0] - 5*Avg[1] + 3*Avg[2] - 5*Avg[3] + 3*Avg[5] + 3*Avg[6] + 3*Avg[7] + 3*Avg[8];
                res[3] = Math.abs(res[3]);
                
                res[4] = -5*Avg[0] - 5*Avg[1] - 5*Avg[2] + 3*Avg[3] + 3*Avg[5] + 3*Avg[6] + 3*Avg[7] + 3*Avg[8];
                res[4] = Math.abs(res[4]);
                
                res[5] = 3*Avg[0] - 5*Avg[1] - 5*Avg[2] + 3*Avg[3] - 5*Avg[5] + 3*Avg[6] + 3*Avg[7] + 3*Avg[8];
                res[5] = Math.abs(res[5]);
                
                res[6] = 3*Avg[0] + 3*Avg[1] - 5*Avg[2] + 3*Avg[3] - 5*Avg[5] + 3*Avg[6] + 3*Avg[7] - 5*Avg[8];
                res[6] = Math.abs(res[6]);
                
                res[7] = 3*Avg[0] + 3*Avg[1] + 3*Avg[2] + 3*Avg[3] - 5*Avg[5] + 3*Avg[6] - 5*Avg[7] - 5*Avg[8];
                res[7] = Math.abs(res[7]);
                
                switch(centre) {
                    case "NO" : max = res[0];
                                break;
                    case "N" :  max = res[1];
                                break;
                    case "NE" : max = res[2];
                                break;
                    case "E" :  max = res[4];
                                break;
                    case "SE" : max = res[7];
                                break;
                    case "S" :  max = res[6];
                                break;
                    case "SO" : max = res[5];
                                break;
                    case "O" :  max = res[3];
                                break;
                    case "Auto" :   max = res[0];
                                    for(int k = 1; k<8; k++) {
                                        if(res[k] > max) {
                                            max = res[k];
                                        }
                                    }
                                    break;                
                }    
                pixel = (max<<24) | (max<<16) | (max<<8) | max;
                tmp.setRGB(i, j, pixel); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    public void sobelFilter() {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int[] P = new int[9]; // Pixel
        int[] Avg = new int[9];
        
        int r, g, b;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
                }

                for(int k=0; k<9; k++) {                   
                    r = (P[k]>>16)&0xff;
                    b = (P[k]>>8)&0xff; 
                    g = P[k]&0xff;

                    Avg[k] = (r+b+g)/3;
                }
               
                int res = -Avg[0] + Avg[2] -2*Avg[3] + 2*Avg[5] - Avg[6] + Avg[8];
                res /= 4;
                res = Math.abs(res);
                
                int res2 = -Avg[0]  -2*Avg[1] - Avg[2] + Avg[6] + 2*Avg[7] + Avg[8];
                res2 /= 4;
                res2 = Math.abs(res2);
                
                res = (res<<24) | (res<<16) | (res<<8) | res;
                res2 = (res2<<24) | (res2<<16) | (res2<<8) | res2;
                res = res | res2;
                
                tmp.setRGB(i, j, res); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    public void prewittFilter() {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int[] P = new int[9]; // Pixel
        int[] Avg = new int[9];
        
        int r, g, b;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
                }

                for(int k=0; k<9; k++) {                   
                    r = (P[k]>>16)&0xff;
                    b = (P[k]>>8)&0xff; 
                    g = P[k]&0xff;

                    Avg[k] = (r+b+g)/3;
                }
               
                int res = -Avg[0] + Avg[2] -Avg[3] + Avg[5] - Avg[6] + Avg[8];
                res /= 3;
                res = Math.abs(res);
                
                res = (res<<24) | (res<<16) | (res<<8) | res; 
                
                int res2 = -Avg[0] + Avg[6] -Avg[1] + Avg[7] - Avg[2] + Avg[8];
                res2 /= 3;
                res2 = Math.abs(res2);
                
                res = (res<<24) | (res<<16) | (res<<8) | res;
                res2 = (res2<<24) | (res2<<16) | (res2<<8) | res2;
                res = res | res2;
                
                tmp.setRGB(i, j, res); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    public void robertsFilter(String centre) {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        int r, g, b;
        
        int[] P = new int[4]; // Pixel
        int[] Avg = new int[4];
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                try {
                    switch(centre) {
                        case "NO" : P[0]=img.getRGB(i, j);
                                    P[1]=img.getRGB(i+1, j);
                                    P[2]=img.getRGB(i, j+1);
                                    P[3]=img.getRGB(i+1, j+1);
                                    break;
                        case "NE" : P[0]=img.getRGB(i-1, j);
                                    P[1]=img.getRGB(i, j);
                                    P[2]=img.getRGB(i-1, j+1);
                                    P[3]=img.getRGB(i, j+1);
                                    break;
                        case "SO" : P[0]=img.getRGB(i, j-1);
                                    P[1]=img.getRGB(i+1, j-1);
                                    P[2]=img.getRGB(i, j);
                                    P[3]=img.getRGB(i+1, j);
                                    break;
                        case "SE" : P[0]=img.getRGB(i-1, j-1);
                                    P[1]=img.getRGB(i, j-1);
                                    P[2]=img.getRGB(i-1, j);
                                    P[3]=img.getRGB(i, j);
                                    break;
                    }
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0; 
                }

                for(int k=0; k<4; k++) {                   
                   r = (P[k]>>16)&0xff;
                   b = (P[k]>>8)&0xff; 
                   g = P[k]&0xff;
                   
                   Avg[k] = (r+b+g)/3;
                }
               
               int res = Avg[0] - Avg[3];
               res = Math.abs(res);
                
               res = (res<<24) | (res<<16) | (res<<8) | res; 
                
               int res2 = Avg[1] - Avg[2];
               res2 = Math.abs(res2);
                
               res = (res<<24) | (res<<16) | (res<<8) | res;
               res2 = (res2<<24) | (res2<<16) | (res2<<8) | res2;
               //res = res | res2;
                
               tmp.setRGB(i, j, res); 
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
    }
    
    /*------------------------ Morphologie ------------------------*/
    public BufferedImage Erosion(int val, BufferedImage imgin) {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc); 
        
        if(imgin != null) {
            img = copyImage(imgin);
        } 
        img = Threshold(val);
        
        int[] P = new int[9]; // Pixel
        int[] Avg = new int[9];
        
        int r, g, b;
        int max = 0; // de base on part de 0
        int pixel;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                max = 0;
                try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
                }

                for(int k=0; k<9; k++) {                   
                    Avg[k] = (P[k]>>16)&0xff; // Les 3 pixels ont la même valeur car on travaille en seuillé
                }
               
                for(int k = 0; k < 9; k++) {
                    if(Avg[k] == 255 && k != 4) {
                        max = 255;
                        break;
                    }
                }
               
                if(max == 255) {
                    pixel = (255<<24) | (255<<16) | (255<<8) | 255; 
                }
                else {
                    pixel = (255<<24) | (0<<16) | (0<<8) | 0; 
                }
                tmp.setRGB(i, j, pixel);
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
        return tmp;
    }
    
    public BufferedImage Dilatation(int val, BufferedImage imgin) {
        BufferedImage img = copyImage(bimgSrc);
        BufferedImage tmp = copyImage(bimgSrc);
        
        if(imgin != null) {
            img = copyImage(imgin);
        }
        img = Threshold(val); 
        
        int[] P = new int[9]; // Pixel
        int[] Avg = new int[9];
        
        int r, g, b;
        int min = 255; // de base on part de 255
        int pixel;
        
        int width = img.getWidth(); 
        int height = img.getHeight(); 
  
        for (int i = 0; i < width; i++) { 
            for (int j = 0; j < height; j++) { 
                min = 255;
                try {
                    P[0]=img.getRGB(i-1,j-1);
                    P[1]=img.getRGB(i-1,j);
                    P[2]=img.getRGB(i-1,j+1);
                    P[3]=img.getRGB(i,j+1);
                    P[4]=img.getRGB(i+1,j+1);
                    P[5]=img.getRGB(i+1,j);
                    P[6]=img.getRGB(i+1,j-1);
                    P[7]=img.getRGB(i,j-1);
                    P[8]=img.getRGB(i,j);
                }
                catch(IndexOutOfBoundsException e) {
                    P[0]=0;
                    P[1]=0;
                    P[2]=0;
                    P[3]=0;
                    P[4]=0;
                    P[5]=0;
                    P[6]=0;
                    P[7]=0;
                    P[8]=img.getRGB(i,j);   
                }

                for(int k=0; k<9; k++) {                   
                    Avg[k] = (P[k]>>16)&0xff; // Les 3 pixels ont la même valeur car on travaille en seuillé
                }
                
                for(int k = 0; k < 9; k++) {
                    if(Avg[k] == 0 && k != 4) {
                        min = 0;
                        break;
                    }
                }
               
                if(min == 255) {
                    pixel = (255<<24) | (255<<16) | (255<<8) | 255; 
                }
                else {
                    pixel = (255<<24) | (0<<16) | (0<<8) | 0; 
                }
                tmp.setRGB(i, j, pixel);
            }   
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
        return tmp;
    }
    
    public BufferedImage Threshold(int val) {
        BufferedImage tmp = copyImage(bimgSrc);
        
        int width = tmp.getWidth(); 
        int height = tmp.getHeight();
                
        for (int y = 0; y < height; y++) { 
            for (int x = 0; x < width; x++) { 
                int p = tmp.getRGB(x,y); 
  
                int a = (p>>24)&0xff; 
                int r = (p>>16)&0xff;
                int g = (p>>8)&0xff; 
                int b = p&0xff; 
                
                int avg = (r+g+b)/3; 
                
                if(avg <= val) {
                    avg = 0;
                }
                else {
                    avg = 255;
                }
                a = 255; // opaque, pour etre sur
                p = (a<<24) | (avg<<16) | (avg<<8) | avg; 
                tmp.setRGB(x, y, p); 
            } 
        }
        bimgDst = tmp; 
        ImageIcon imageIcon = new ImageIcon(tmp);
        ImageDst.setIcon(imageIcon);
        return tmp;
    }
    
    /*------------------------ Histogramme ------------------------*/
    protected void updateHistogram(JLabel histogram, JLabel image) {
        values = new int[256];
        int highValue = 0;
        ImageIcon icon = (ImageIcon) image.getIcon();
        BufferedImage img = getBufferedImage(icon);

        // nombre de pixels de meme valeur 
        for (int i = 0; i < img.getWidth(); i++) {
            for (int j = 0; j < img.getHeight(); j++) {
                values[img.getRGB(i, j) & 0xFF]++; // ajoute 1 a la valeur de la couleur 
            }
        }

        // couleur avec le plus de pixels 
        minValue = -1;
        for (int i = 0; i < values.length; i++) {
            if (values[i] > img.getWidth() * img.getHeight() / 100) // récupère le min et le max pour égalisation 
            {
                maxValue = i;

                if (minValue == -1) {
                    if (i == 0) {
                        minValue = 0;
                    } else {
                        minValue = i;
                    }
                }
            }
            if (values[i] > values[highValue]) {
                highValue = i;
            }
        }

        BufferedImage histo = new BufferedImage(histogram.getWidth(), histogram.getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = histo.createGraphics();

        for (int i = 0; i < values.length; i++) {
            g2d.setColor(new Color(i, i, i));
            g2d.drawLine(i, histo.getHeight(), i, histo.getHeight() - (int) ((double) values[i] / values[highValue] * histo.getHeight()));
        }
        g2d.dispose();
        histogram.setIcon(new ImageIcon(histo));
    }

    private void Egalisation() {
        int rgba, value;
        int[] cumulValues = new int[256];

        ImageIcon icon = (ImageIcon) ImageSrc.getIcon();
        BufferedImage img = getBufferedImage(icon);
        int total = img.getWidth() * img.getHeight();

        cumulValues[0] = values[0];
        for (int i = 1; i < 256; i++) {
            cumulValues[i] = cumulValues[i - 1] + values[i];
        }

        float[] arr = new float[256];
        for (int i = 0; i < 256; i++) {
            arr[i] = (float) ((cumulValues[i] * 255.0) / (float) total);
        }
        for (int i = 0; i < img.getWidth(); i++) {
            for (int j = 0; j < img.getHeight(); j++) {
                rgba = img.getRGB(i, j);
                value = (int) arr[img.getRGB(i, j) & 0xFF];

                rgba = (rgba & 0xFF000000) + (value << 16) + (value << 8) + value;

                img.setRGB(i, j, rgba);
            }
        }
        ImageDst.setIcon(new ImageIcon(img));
        updateHistogram(histoImg2, ImageDst);
    }

    /*------------------------ Pour interpolation bilinéaire ------------------------*/
    private static int get(int self, int n) {
        return (self >> (n * 8)) & 0xFF;
    }

    private static float linInt(float s, float e, float t) {
        return s + (e - s) * t;
    }

    private static float bilinInt(final Float c00, float c10, float c01, float c11, float tx, float ty) {
        return linInt(linInt(c00, c10, tx), linInt(c01, c11, tx), ty);
    }

    private static BufferedImage scale(BufferedImage self, float scaleX, float scaleY) {
        int newWidth = (int) (self.getWidth() * scaleX);
        int newHeight = (int) (self.getHeight() * scaleY);
        BufferedImage newImage = new BufferedImage(newWidth, newHeight, self.getType());
        for (int x = 0; x < newWidth; ++x) {
            for (int y = 0; y < newHeight; ++y) {
                float gx = ((float) x) / newWidth * (self.getWidth() - 1);
                float gy = ((float) y) / newHeight * (self.getHeight() - 1);
                int gxi = (int) gx;
                int gyi = (int) gy;
                int rgb = 0;
                int c00 = self.getRGB(gxi, gyi);
                int c10 = self.getRGB(gxi + 1, gyi);
                int c01 = self.getRGB(gxi, gyi + 1);
                int c11 = self.getRGB(gxi + 1, gyi + 1);
                for (int i = 0; i <= 2; ++i) {
                    float b00 = get(c00, i);
                    float b10 = get(c10, i);
                    float b01 = get(c01, i);
                    float b11 = get(c11, i);
                    int ble = ((int) bilinInt(b00, b10, b01, b11, gx - gxi, gy - gyi)) << (8 * i);
                    rgb = rgb | ble;
                }
                newImage.setRGB(x, y, rgb);
            }
        }
        return newImage;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FenetrePrincipale.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FenetrePrincipale.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FenetrePrincipale.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FenetrePrincipale.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FenetrePrincipale().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    protected javax.swing.JTextField ChoixExpanExtracX;
    protected javax.swing.JTextField ChoixExpanExtracY;
    protected javax.swing.JTextField ChoixThreshold;
    protected javax.swing.JTextField ChoixZoom;
    protected javax.swing.JButton EgalisationButton;
    protected javax.swing.JButton Expan_Extra_Button;
    protected javax.swing.JLabel ImageDst;
    protected javax.swing.JLabel ImageSrc;
    private javax.swing.JMenu MenuFile;
    private javax.swing.JMenu MenuFiltres;
    private javax.swing.JMenuItem MenuLoadImage;
    private javax.swing.JMenu MenuMasques;
    private javax.swing.JMenu MenuOperations;
    protected javax.swing.JMenuItem MultiThresholdMenu;
    protected javax.swing.JMenuItem PaletteMenu;
    protected javax.swing.JMenuItem ROIMenu;
    protected javax.swing.JButton ThresholdButton;
    protected javax.swing.JButton UpdateSourceImage;
    protected javax.swing.JButton ZoomButton;
    private javax.swing.JButton dilatationButton;
    private javax.swing.JTextField dilatationTxt;
    private javax.swing.JButton erosionButton;
    private javax.swing.JTextField erosionTxt;
    private javax.swing.JButton fermetureButton;
    private javax.swing.JTextField fermetureTxt;
    protected javax.swing.JMenuItem gaussienMenu;
    protected javax.swing.JLabel histoImg1;
    protected javax.swing.JLabel histoImg2;
    private javax.swing.JButton jButton1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    protected javax.swing.JMenuItem kirshMenu;
    protected javax.swing.JMenuItem laplacienMenu;
    protected javax.swing.JMenuItem medianMenu;
    protected javax.swing.JMenuItem moyenMenu;
    private javax.swing.JButton ouvertureButton;
    private javax.swing.JTextField ouvertureTxt;
    protected javax.swing.JMenuItem prewittMenu;
    protected javax.swing.JMenuItem robertsMenu;
    protected javax.swing.JMenuItem sobelMenu;
    // End of variables declaration//GEN-END:variables
}
